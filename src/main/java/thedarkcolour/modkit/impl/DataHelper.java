package thedarkcolour.modkit.impl;

import net.minecraft.core.HolderLookup;
import net.minecraft.core.Registry;
import net.minecraft.data.DataProvider;
import net.minecraft.data.PackOutput;
import net.minecraft.data.recipes.FinishedRecipe;
import net.minecraft.resources.ResourceKey;
import net.minecraftforge.common.util.Lazy;
import net.minecraftforge.data.event.GatherDataEvent;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import thedarkcolour.modkit.ModKit;
import thedarkcolour.modkit.data.IDataHelper;
import thedarkcolour.modkit.data.IRecipeProvider;
import thedarkcolour.modkit.data.ITagsProvider;
import thedarkcolour.modkit.data.MKBlockModelProvider;
import thedarkcolour.modkit.data.MKEnglishProvider;
import thedarkcolour.modkit.data.MKItemModelProvider;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;

/**
 * Use this in your event handler for GatherDataEvent. To avoid requiring ModKit in-game,
 * GatherDataEvent should be in a separate class from mod code. See the examples package.
 * For a more detailed example, check the "src/test/" directory on ModKit's GitHub.
 * <p>
 * Methods which specify what to generate follow the naming scheme "createBlah" and always
 * have a consumer (usually nullable) as their last parameter which gets run at the appropriate
 * time during data generation. For example, while you'd normally write translation code in
 * LanguageProvider#addTranslations, you would write it in the consumer you pass as the last
 * argument for {@link #createEnglish}, either with a method reference to a static method
 * "addTranslations" in your own data generation class. If you do not need any additional
 * translations aside from what's automatically generated by ModKit, you may simply pass null.
 */
@SuppressWarnings({"unused", "UnusedReturnValue"})
public class DataHelper implements IDataHelper {
    protected final String modid;
    protected final GatherDataEvent event;
    protected final Logger logger;
    protected final Map<ResourceKey<?>, MKTagsProvider<?>> tags;

    @Nullable
    protected MKEnglishProvider english;
    @Nullable
    protected MKItemModelProvider itemModels;
    @Nullable
    protected MKBlockModelProvider blockModels;
    @Nullable
    protected MKRecipeProvider recipes;
    @Nullable
    protected BiFunction<MKEnglishProvider, PackOutput, List<DataProvider>> addModonomiconBooks;

    public DataHelper(String modid, GatherDataEvent event) {
        this.modid = modid;
        this.event = event;
        this.logger = LoggerFactory.getLogger(ModKit.ID + "/" + modid);
        this.tags = new HashMap<>();
    }

    @Override
    public MKEnglishProvider createEnglish(boolean generateNames, @Nullable Consumer<MKEnglishProvider> addTranslations) {
        this.checkNotCreated(this.english, "English language");

        this.english = new MKEnglishProvider(event.getGenerator().getPackOutput(), this.modid, this.logger, generateNames, addTranslations);

        if (addModonomiconBooks != null) {
            for (DataProvider book : addModonomiconBooks.apply(this.english, this.event.getGenerator().getPackOutput())) {
                this.event.getGenerator().addProvider(true, book);
            }
        }

        this.event.getGenerator().addProvider(this.event.includeClient(), this.english);

        return this.english;
    }

    @Override
    public void createModonomiconBooks(boolean customEnglish, BiFunction<MKEnglishProvider, PackOutput, List<DataProvider>> addBooks) {
        this.addModonomiconBooks = addBooks;

        if (!customEnglish) {
            this.createEnglish(false, null);
        }
    }

    @Override
    public MKItemModelProvider createItemModels(boolean generate3dBlockItems, boolean generate2dItems, boolean generateSpawnEggs, @Nullable Consumer<MKItemModelProvider> addItemModels) {
        this.checkNotCreated(this.itemModels, "Item models");

        this.itemModels = new MKItemModelProvider(this.event.getGenerator().getPackOutput(), this.event.getExistingFileHelper(), this.modid, this.logger, generate3dBlockItems, generate2dItems, generateSpawnEggs, addItemModels);
        this.event.getGenerator().addProvider(this.event.includeClient(), this.itemModels);

        return this.itemModels;
    }

    @Override
    public MKBlockModelProvider createBlockModels(Consumer<MKBlockModelProvider> addBlockModels) {
        this.checkNotCreated(this.blockModels, "Block models");

        if (this.itemModels != null) {
            // Ex. Item models which use block models as parents will log errors that those block models don't exist,
            // because data providers run in creation order so block models wouldn't have generated yet.
            this.logger.warn("Item model generation was added BEFORE block model generation; this is incorrect, expect some false alarm errors");
        }

        // Lazy is used so that createItemModels is called automatically if your mod isn't using it
        Lazy<MKItemModelProvider> lazyItemModels = Lazy.of(() -> {
            if (this.itemModels == null) {
                this.createItemModels(false, false, false, null);
                this.event.getGenerator().addProvider(this.event.includeClient(), this.itemModels);
            }
            return this.itemModels;
        });

        this.blockModels = new MKBlockModelProvider(this.event.getGenerator().getPackOutput(), this.event.getExistingFileHelper(), lazyItemModels, this.modid, this.logger, addBlockModels);
        this.event.getGenerator().addProvider(this.event.includeClient(), this.blockModels);

        return this.blockModels;
    }

    @Override
    public IRecipeProvider createRecipes(BiConsumer<Consumer<FinishedRecipe>, MKRecipeProvider> addRecipes) {
        this.checkNotCreated(this.recipes, "Recipes");

        this.recipes = new MKRecipeProvider(this.event.getGenerator().getPackOutput(), addRecipes);
        this.event.getGenerator().addProvider(this.event.includeServer(), this.recipes);

        return this.recipes;
    }

    @Override
    public <T> ITagsProvider<T> createTags(ResourceKey<? extends Registry<T>> registry, BiConsumer<MKTagsProvider<T>, HolderLookup.Provider> addTags) {
        this.checkNotCreated(this.tags.get(registry), "Tags for " + registry.location());

        var provider = new MKTagsProvider<>(this, registry, addTags);
        this.tags.put(registry, provider);
        this.event.getGenerator().addProvider(this.event.includeServer(), provider);

        return provider;
    }

    private void checkNotCreated(@Nullable Object obj, String provider) {
        if (obj != null) {
            throw new IllegalStateException(provider + " generation already created!");
        }
    }
}
