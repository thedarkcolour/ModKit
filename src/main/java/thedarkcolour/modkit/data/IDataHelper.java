package thedarkcolour.modkit.data;

import net.minecraft.core.HolderLookup;
import net.minecraft.core.Registry;
import net.minecraft.data.DataProvider;
import net.minecraft.data.PackOutput;
import net.minecraft.data.recipes.FinishedRecipe;
import net.minecraft.resources.ResourceKey;
import net.minecraftforge.data.event.GatherDataEvent;
import org.jetbrains.annotations.Nullable;
import thedarkcolour.modkit.impl.DataHelper;
import thedarkcolour.modkit.impl.MKRecipeProvider;
import thedarkcolour.modkit.impl.MKTagsProvider;

import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;

public interface IDataHelper {
    /**
     * To use ModKit's Data generation tools, start here.
     *
     * @param modid Your mod's modid you want to generate data for
     * @param event The gather data event containing pack output, data generator, existing file helper, etc.
     * @return A new instance of IDataHelper
     */
    static IDataHelper create(String modid, GatherDataEvent event) {
        return new DataHelper(modid, event);
    }

    /**
     * Generates English language translations for your mod.
     *
     * @param generateNames   Whether to automatically generate names based on registry names.
     *                        For example, "minecraft:gold_ingot" would become "Gold Ingot".
     *                        Cases where this does not work is if your registry names do not follow
     *                        proper convention, or if you use acronyms: "projecte:emc_gun" would be "Emc Gun"
     *                        instead of "EMC Gun" and "mymod:exampleblock" would be "Exampleblock" instead of "Example Block"
     * @param addTranslations If not null, a consumer ran in LanguageProvider.addTranslations AFTER names are autogenerated,
     *                        so you can add in names that were generated incorrectly or names for things like Creative Tabs.
     */
    @SuppressWarnings("SpellCheckingInspection")
    MKEnglishProvider createEnglish(boolean generateNames, @Nullable Consumer<MKEnglishProvider> addTranslations);

    /**
     * Use this to register your Modonomicon books before the language generation is created.
     *
     * @param customEnglish Whether you are calling {{@link #createEnglish(boolean, Consumer)}} later. If false,
     *                      this method will use an MKEnglishProvider that doesn't generate names.
     * @param addBooks      Create your book providers here, return them as a list.
     */
    void createModonomiconBooks(boolean customEnglish, BiFunction<MKEnglishProvider, PackOutput, List<DataProvider>> addBooks);

    /**
     * Generates item models for your mod. If you also have Block Models, call this AFTER calling {@link #createBlockModels}
     *
     * @param generate3dBlockItems If true, BlockItems are given generic 3D item models (ex. dirt, diamond block)
     * @param generate2dItems      If true, non-BlockItems are given generic 2D item models (ex. gold ingot)
     *                             and SwordItem/PickaxeItem/ShovelItem/etc. items will be given handheld item models (ex. wooden pickaxe)
     * @param generateSpawnEggs    If true, SpawnEggItems are given spawn egg item models
     * @param addItemModels        Function (nullable) to add/override generated models for items. If you are using generate3dBlockItems
     *                             or generate2dItems and you want to change which model an item is generated with, do so in
     *                             this function.
     */
    MKItemModelProvider createItemModels(boolean generate3dBlockItems, boolean generate2dItems, boolean generateSpawnEggs, @Nullable Consumer<MKItemModelProvider> addItemModels);

    /**
     * Generates block models for your mod. The MKBlockModelProvider provides some template models
     * you can use, but if you need anything more complicated it's best to write your own methods and
     * use them in the method you pass in for addBlockModels.
     *
     * @param addBlockModels Non-null function which receives the MKBlockModelProvider, which inherits methods from
     *                       BlockStateProvider and has some other methods to generate models.
     */
    MKBlockModelProvider createBlockModels(Consumer<MKBlockModelProvider> addBlockModels);

    /**
     * Generates recipes of all kinds for your mod.
     *
     * @param addRecipes Non-null function which receives the finished recipe writer and MKRecipeProvider, which has
     *                   built-in methods for common recipe types. If you need something more advanced, you may write
     *                   methods using the given finished recipe writer and call them in your addRecipes function.
     */
    IRecipeProvider createRecipes(BiConsumer<Consumer<FinishedRecipe>, MKRecipeProvider> addRecipes);

    /**
     * Generates tags for a specific registry. For item tags, you may use the copy() method
     * to copy equivalent block tags into your item tags.
     *
     * @param registry The registry to generate tags for
     * @param addTags  A function that takes in the tag provider and a holder lookup provider in order to generate tags.
     * @param <T>      The type of objects to generate tags for
     * @return The tag provider, not sure what you'd use this for.
     */
    <T> ITagsProvider<T> createTags(ResourceKey<? extends Registry<T>> registry, BiConsumer<MKTagsProvider<T>, HolderLookup.Provider> addTags);

    /**
     * Alternative method which omits the often unused HolderLookup.Provider parameter.
     *
     * @see DataHelper#createTags(ResourceKey, BiConsumer)
     */
    default <T> ITagsProvider<T> createTags(ResourceKey<? extends Registry<T>> registry, Consumer<MKTagsProvider<T>> addTags) {
        return this.createTags(registry, (tags, lookup) -> addTags.accept(tags));
    }
}
